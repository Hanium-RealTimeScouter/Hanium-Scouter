// Generated by delombok at Sun Feb 26 12:31:38 KST 2017
package scouter.bytebuddy.implementation;

import scouter.bytebuddy.description.method.MethodDescription;
import scouter.bytebuddy.description.type.TypeDescription;
import scouter.bytebuddy.dynamic.scaffold.InstrumentedType;

import scouter.bytebuddy.implementation.bytecode.*;
import scouter.bytebuddy.implementation.bytecode.constant.TextConstant;
import scouter.bytebuddy.implementation.bytecode.member.MethodInvocation;
import scouter.bytebuddy.jar.asm.MethodVisitor;
import scouter.bytebuddy.matcher.ElementMatchers;

import static scouter.bytebuddy.matcher.ElementMatchers.takesArguments;

/**
 * This implementation causes a {@link java.lang.Throwable} to be thrown when the instrumented method is invoked.
 * Be aware that the Java Virtual machine does not care about exception declarations and will throw any
 * {@link java.lang.Throwable} from any method even if the method does not declared a checked exception.
 */
public class ExceptionMethod implements Implementation, ByteCodeAppender {
    /**
     * The type of the exception that is thrown.
     */
    private final TypeDescription throwableType;
    /**
     * The construction delegation which is responsible for creating the exception to be thrown.
     */
    private final ConstructionDelegate constructionDelegate;

    /**
     * Creates a new instance of an implementation for throwing throwables.
     *
     * @param throwableType        The type of the exception to be thrown.
     * @param constructionDelegate A delegate that is responsible for calling the isThrowable's constructor.
     */
    public ExceptionMethod(TypeDescription throwableType, ConstructionDelegate constructionDelegate) {
        this.throwableType = throwableType;
        this.constructionDelegate = constructionDelegate;
    }

    /**
     * Creates an implementation that creates a new instance of the given isThrowable type on each method invocation
     * which is then thrown immediately. For this to be possible, the given type must define a default constructor
     * which is visible from the instrumented type.
     *
     * @param exceptionType The type of the isThrowable.
     * @return An implementation that will throw an instance of the isThrowable on each method invocation of the
     * instrumented methods.
     */
    public static Implementation throwing(Class<? extends Throwable> exceptionType) {
        return throwing(new TypeDescription.ForLoadedType(exceptionType));
    }

    /**
     * Creates an implementation that creates a new instance of the given isThrowable type on each method invocation
     * which is then thrown immediately. For this to be possible, the given type must define a default constructor
     * which is visible from the instrumented type.
     *
     * @param exceptionType The type of the isThrowable.
     * @return An implementation that will throw an instance of the isThrowable on each method invocation of the
     * instrumented methods.
     */
    public static Implementation throwing(TypeDescription exceptionType) {
        if (!exceptionType.isAssignableTo(Throwable.class)) {
            throw new IllegalArgumentException(exceptionType + " does not extend throwable");
        }
        return new ExceptionMethod(exceptionType, new ConstructionDelegate.ForDefaultConstructor(exceptionType));
    }

    /**
     * Creates an implementation that creates a new instance of the given isThrowable type on each method invocation
     * which is then thrown immediately. For this to be possible, the given type must define a constructor that
     * takes a single {@link java.lang.String} as its argument.
     *
     * @param exceptionType The type of the isThrowable.
     * @param message       The string that is handed to the constructor. Usually an exception message.
     * @return An implementation that will throw an instance of the isThrowable on each method invocation of the
     * instrumented methods.
     */
    public static Implementation throwing(Class<? extends Throwable> exceptionType, String message) {
        return throwing(new TypeDescription.ForLoadedType(exceptionType), message);
    }

    /**
     * Creates an implementation that creates a new instance of the given isThrowable type on each method invocation
     * which is then thrown immediately. For this to be possible, the given type must define a constructor that
     * takes a single {@link java.lang.String} as its argument.
     *
     * @param exceptionType The type of the isThrowable.
     * @param message       The string that is handed to the constructor. Usually an exception message.
     * @return An implementation that will throw an instance of the isThrowable on each method invocation of the
     * instrumented methods.
     */
    public static Implementation throwing(TypeDescription exceptionType, String message) {
        if (!exceptionType.isAssignableTo(Throwable.class)) {
            throw new IllegalArgumentException(exceptionType + " does not extend throwable");
        }
        return new ExceptionMethod(exceptionType, new ConstructionDelegate.ForStringConstructor(exceptionType, message));
    }

    @Override
    public InstrumentedType prepare(InstrumentedType instrumentedType) {
        return instrumentedType;
    }

    @Override
    public ByteCodeAppender appender(Target implementationTarget) {
        return this;
    }

    @Override
    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
        StackManipulation.Size stackSize = new StackManipulation.Compound(constructionDelegate.make(), Throw.INSTANCE).apply(methodVisitor, implementationContext);
        return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
    }


    /**
     * A construction delegate is responsible for calling a Throwable's constructor.
     */
    public interface ConstructionDelegate {
        /**
         * Creates a stack manipulation that creates pushes all constructor arguments onto the operand stack
         * and subsequently calls the constructor.
         *
         * @return A stack manipulation for constructing a isThrowable.
         */
        StackManipulation make();

        /**
         * A construction delegate that calls the default constructor.
         */
        class ForDefaultConstructor implements ConstructionDelegate {
            /**
             * The type of the exception that is to be thrown.
             */
            private final TypeDescription exceptionType;
            /**
             * The constructor that is used for creating the exception.
             */
            private final MethodDescription targetConstructor;

            /**
             * Creates a new construction delegate that calls a default constructor.
             *
             * @param exceptionType The type of the isThrowable.
             */
            public ForDefaultConstructor(TypeDescription exceptionType) {
                this.exceptionType = exceptionType;
                this.targetConstructor = exceptionType.getDeclaredMethods().filter(ElementMatchers.isConstructor().and(ElementMatchers.takesArguments(0))).getOnly();
            }

            @Override
            public StackManipulation make() {
                return new StackManipulation.Compound(TypeCreation.of(exceptionType), Duplication.SINGLE, MethodInvocation.invoke(targetConstructor));
            }

            @java.lang.Override
            @java.lang.SuppressWarnings("all")
            @javax.annotation.Generated("lombok")
            public boolean equals(final java.lang.Object o) {
                if (o == this) return true;
                if (!(o instanceof ExceptionMethod.ConstructionDelegate.ForDefaultConstructor)) return false;
                final ExceptionMethod.ConstructionDelegate.ForDefaultConstructor other = (ExceptionMethod.ConstructionDelegate.ForDefaultConstructor) o;
                if (!other.canEqual((java.lang.Object) this)) return false;
                final java.lang.Object this$exceptionType = this.exceptionType;
                final java.lang.Object other$exceptionType = other.exceptionType;
                if (this$exceptionType == null ? other$exceptionType != null : !this$exceptionType.equals(other$exceptionType)) return false;
                final java.lang.Object this$targetConstructor = this.targetConstructor;
                final java.lang.Object other$targetConstructor = other.targetConstructor;
                if (this$targetConstructor == null ? other$targetConstructor != null : !this$targetConstructor.equals(other$targetConstructor)) return false;
                return true;
            }

            @java.lang.SuppressWarnings("all")
            @javax.annotation.Generated("lombok")
            protected boolean canEqual(final java.lang.Object other) {
                return other instanceof ExceptionMethod.ConstructionDelegate.ForDefaultConstructor;
            }

            @java.lang.Override
            @java.lang.SuppressWarnings("all")
            @javax.annotation.Generated("lombok")
            public int hashCode() {
                final int PRIME = 59;
                int result = 1;
                final java.lang.Object $exceptionType = this.exceptionType;
                result = result * PRIME + ($exceptionType == null ? 43 : $exceptionType.hashCode());
                final java.lang.Object $targetConstructor = this.targetConstructor;
                result = result * PRIME + ($targetConstructor == null ? 43 : $targetConstructor.hashCode());
                return result;
            }
        }

        /**
         * A construction delegate that calls a constructor that takes a single string as its argument.
         */
        class ForStringConstructor implements ConstructionDelegate {
            /**
             * The type of the exception that is to be thrown.
             */
            private final TypeDescription exceptionType;
            /**
             * The constructor that is used for creating the exception.
             */
            private final MethodDescription targetConstructor;
            /**
             * The {@link java.lang.String} that is to be passed to the exception's constructor.
             */
            private final String message;

            /**
             * Creates a new construction delegate that calls a constructor by handing it the given string.
             *
             * @param exceptionType The type of the isThrowable.
             * @param message       The string that is handed to the constructor.
             */
            public ForStringConstructor(TypeDescription exceptionType, String message) {
                this.exceptionType = exceptionType;
                this.targetConstructor = exceptionType.getDeclaredMethods().filter(ElementMatchers.isConstructor().and(ElementMatchers.takesArguments(String.class))).getOnly();
                this.message = message;
            }

            @Override
            public StackManipulation make() {
                return new StackManipulation.Compound(TypeCreation.of(exceptionType), Duplication.SINGLE, new TextConstant(message), MethodInvocation.invoke(targetConstructor));
            }

            @java.lang.Override
            @java.lang.SuppressWarnings("all")
            @javax.annotation.Generated("lombok")
            public boolean equals(final java.lang.Object o) {
                if (o == this) return true;
                if (!(o instanceof ExceptionMethod.ConstructionDelegate.ForStringConstructor)) return false;
                final ExceptionMethod.ConstructionDelegate.ForStringConstructor other = (ExceptionMethod.ConstructionDelegate.ForStringConstructor) o;
                if (!other.canEqual((java.lang.Object) this)) return false;
                final java.lang.Object this$exceptionType = this.exceptionType;
                final java.lang.Object other$exceptionType = other.exceptionType;
                if (this$exceptionType == null ? other$exceptionType != null : !this$exceptionType.equals(other$exceptionType)) return false;
                final java.lang.Object this$targetConstructor = this.targetConstructor;
                final java.lang.Object other$targetConstructor = other.targetConstructor;
                if (this$targetConstructor == null ? other$targetConstructor != null : !this$targetConstructor.equals(other$targetConstructor)) return false;
                final java.lang.Object this$message = this.message;
                final java.lang.Object other$message = other.message;
                if (this$message == null ? other$message != null : !this$message.equals(other$message)) return false;
                return true;
            }

            @java.lang.SuppressWarnings("all")
            @javax.annotation.Generated("lombok")
            protected boolean canEqual(final java.lang.Object other) {
                return other instanceof ExceptionMethod.ConstructionDelegate.ForStringConstructor;
            }

            @java.lang.Override
            @java.lang.SuppressWarnings("all")
            @javax.annotation.Generated("lombok")
            public int hashCode() {
                final int PRIME = 59;
                int result = 1;
                final java.lang.Object $exceptionType = this.exceptionType;
                result = result * PRIME + ($exceptionType == null ? 43 : $exceptionType.hashCode());
                final java.lang.Object $targetConstructor = this.targetConstructor;
                result = result * PRIME + ($targetConstructor == null ? 43 : $targetConstructor.hashCode());
                final java.lang.Object $message = this.message;
                result = result * PRIME + ($message == null ? 43 : $message.hashCode());
                return result;
            }
        }
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @javax.annotation.Generated("lombok")
    public boolean equals(final java.lang.Object o) {
        if (o == this) return true;
        if (!(o instanceof ExceptionMethod)) return false;
        final ExceptionMethod other = (ExceptionMethod) o;
        if (!other.canEqual((java.lang.Object) this)) return false;
        final java.lang.Object this$throwableType = this.throwableType;
        final java.lang.Object other$throwableType = other.throwableType;
        if (this$throwableType == null ? other$throwableType != null : !this$throwableType.equals(other$throwableType)) return false;
        final java.lang.Object this$constructionDelegate = this.constructionDelegate;
        final java.lang.Object other$constructionDelegate = other.constructionDelegate;
        if (this$constructionDelegate == null ? other$constructionDelegate != null : !this$constructionDelegate.equals(other$constructionDelegate)) return false;
        return true;
    }

    @java.lang.SuppressWarnings("all")
    @javax.annotation.Generated("lombok")
    protected boolean canEqual(final java.lang.Object other) {
        return other instanceof ExceptionMethod;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @javax.annotation.Generated("lombok")
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final java.lang.Object $throwableType = this.throwableType;
        result = result * PRIME + ($throwableType == null ? 43 : $throwableType.hashCode());
        final java.lang.Object $constructionDelegate = this.constructionDelegate;
        result = result * PRIME + ($constructionDelegate == null ? 43 : $constructionDelegate.hashCode());
        return result;
    }
}
