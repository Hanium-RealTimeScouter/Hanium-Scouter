// Generated by delombok at Sun Feb 26 12:31:38 KST 2017
package scouter.bytebuddy.dynamic.scaffold.inline;

import scouter.bytebuddy.description.method.MethodDescription;
import scouter.bytebuddy.description.type.TypeDescription;
import scouter.bytebuddy.matcher.ElementMatcher;
import scouter.bytebuddy.matcher.ElementMatchers;
import scouter.bytebuddy.matcher.LatentMatcher;
import static scouter.bytebuddy.matcher.ElementMatchers.*;

/**
 * A latent method matcher that identifies methods to instrument when redefining or rebasing a type.
 */
public class InliningImplementationMatcher implements LatentMatcher<MethodDescription> {
    /**
     * A method matcher that matches any ignored method.
     */
    private final LatentMatcher<? super MethodDescription> ignoredMethods;
    /**
     * A method matcher that matches any predefined method.
     */
    private final ElementMatcher<? super MethodDescription> predefinedMethodSignatures;

    /**
     * Creates a new inline implementation matcher.
     *
     * @param ignoredMethods             A method matcher that matches any ignored method.
     * @param predefinedMethodSignatures A method matcher that matches any predefined method.
     */
    protected InliningImplementationMatcher(LatentMatcher<? super MethodDescription> ignoredMethods, ElementMatcher<? super MethodDescription> predefinedMethodSignatures) {
        this.ignoredMethods = ignoredMethods;
        this.predefinedMethodSignatures = predefinedMethodSignatures;
    }

    /**
     * Creates a matcher where only overridable or declared methods are matched unless those are ignored. Methods that
     * are declared by the target type are only matched if they are not ignored. Declared methods that are not found on the
     * target type are always matched.
     *
     * @param ignoredMethods A method matcher that matches any ignored method.
     * @param originalType   The original type of the instrumentation before adding any user methods.
     * @return A latent method matcher that identifies any method to instrument for a rebasement or redefinition.
     */
    protected static LatentMatcher<MethodDescription> of(LatentMatcher<? super MethodDescription> ignoredMethods, TypeDescription originalType) {
        ElementMatcher.Junction<MethodDescription> predefinedMethodSignatures = none();
        for (MethodDescription methodDescription : originalType.getDeclaredMethods()) {
            ElementMatcher.Junction<MethodDescription> signature = methodDescription.isConstructor() ? isConstructor() : ElementMatchers.<MethodDescription>named(methodDescription.getName());
            signature = signature.and(returns(methodDescription.getReturnType().asErasure()));
            signature = signature.and(takesArguments(methodDescription.getParameters().asTypeList().asErasures()));
            predefinedMethodSignatures = predefinedMethodSignatures.or(signature);
        }
        return new InliningImplementationMatcher(ignoredMethods, predefinedMethodSignatures);
    }

    @Override
    public ElementMatcher<? super MethodDescription> resolve(TypeDescription typeDescription) {
        return (ElementMatcher<? super MethodDescription>) not(ignoredMethods.resolve(typeDescription)).and(isVirtual().and(not(isFinal())).or(isDeclaredBy(typeDescription))).or(isDeclaredBy(typeDescription).and(not(predefinedMethodSignatures)));
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @javax.annotation.Generated("lombok")
    public boolean equals(final java.lang.Object o) {
        if (o == this) return true;
        if (!(o instanceof InliningImplementationMatcher)) return false;
        final InliningImplementationMatcher other = (InliningImplementationMatcher) o;
        if (!other.canEqual((java.lang.Object) this)) return false;
        final java.lang.Object this$ignoredMethods = this.ignoredMethods;
        final java.lang.Object other$ignoredMethods = other.ignoredMethods;
        if (this$ignoredMethods == null ? other$ignoredMethods != null : !this$ignoredMethods.equals(other$ignoredMethods)) return false;
        final java.lang.Object this$predefinedMethodSignatures = this.predefinedMethodSignatures;
        final java.lang.Object other$predefinedMethodSignatures = other.predefinedMethodSignatures;
        if (this$predefinedMethodSignatures == null ? other$predefinedMethodSignatures != null : !this$predefinedMethodSignatures.equals(other$predefinedMethodSignatures)) return false;
        return true;
    }

    @java.lang.SuppressWarnings("all")
    @javax.annotation.Generated("lombok")
    protected boolean canEqual(final java.lang.Object other) {
        return other instanceof InliningImplementationMatcher;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    @javax.annotation.Generated("lombok")
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final java.lang.Object $ignoredMethods = this.ignoredMethods;
        result = result * PRIME + ($ignoredMethods == null ? 43 : $ignoredMethods.hashCode());
        final java.lang.Object $predefinedMethodSignatures = this.predefinedMethodSignatures;
        result = result * PRIME + ($predefinedMethodSignatures == null ? 43 : $predefinedMethodSignatures.hashCode());
        return result;
    }
}
